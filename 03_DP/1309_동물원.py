"""
날짜 <2023/03/07 (화)>
- 문제 링크: https://www.acmicpc.net/problem/1309
- 문제 요약
    사자를 가로로도 세로로도 붙어 있게 배치할 수는 없다.
    2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

- 상상 코딩
    2가지 수를 1로 두고 반복하며 처음수를 앞의 두수의 합, 뒤의 수를 앞의 두수의 합 + 뒤의수로 하면 된다는 규칙을 발견했다. 해당 규칙대로 풉니다.

- 체감 난이도 (1:쉬움 ~ 5:매우 어려움)
    2
- 문제 분석

    - 알고리즘 유형 분석
        앞의 연산을 뒤에서 불러와서 하는 메모이제이션을 활용한 DP 유형입니다.
    - 시간복잡도 분석
        O(N)입니다.
    - 리팩토링 방향성
        li를 갱신하는 방향으로 했는데, 바로 변수에 전달 할 수 있습니다.
        변수에 전달할 때 9901로 나눈 수를 전달하니 계산되는 숫자가 줄면서 속도가 10배이상 빨라졌습니다.
    
"""
## 파일로 예제 입력 읽기
import sys
sys.stdin = open("input.txt",'r')
##
N=int(input())
li=[1,1]
for i in range(N):
    s=sum(li)
    li=s,s+li[0]
print(li[1]%9901)

## 리팩토링 풀이
N=int(input())
a,b=1,1
for i in range(N):
    a,b=(a+b)%9901,(2*a+b)%9901
print(b)