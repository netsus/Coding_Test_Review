"""
날짜 <2023/03/05 (일)>
- 문제 링크: https://www.acmicpc.net/problem/15787
- 문제 요약
    기차는 20개의 일렬로 된 좌석이 있고, 한 개의 좌석에는 한 명의 사람이 탈 수 있다. 
    기차의 번호를 1번부터 N번으로 매길 때, 어떠한 기차에 대하여 M개의 명령
    명령의 종류는 4가지로 다음과 같다.

    1 i x : i번째 기차(1 ≤ i ≤ N) x번째 좌석(1 ≤ x ≤ 20) 사람 태우기. 이미 있다면 , 아무런 행동 하지않음.
    2 i x : i번째 기차 x번째 좌석 사람 하차. 만약 아무도 그자리에 앉아있지 않았다면, 아무런 행동을 하지 않는다.
    3 i : i번째 기차에 앉아있는 승객들이 모두 한칸씩 뒤로간다. k번째 앉은 사람은 k+1번째로 이동하여 앉는다. 만약 20번째 자리에 사람이 앉아있었다면 그 사람은 이 명령 후에 하차한다.
    4 i : i번째 기차에 앉아있는 승객들이 모두 한칸씩 앞으로간다. k번째 앉은 사람은 k-1 번째 자리로 이동하여 앉는다. 만약 1번째 자리에 사람이 앉아있었다면 그 사람은 이 명령 후에 하차

    기차수 N(1 ≤ N ≤ 100000)과 명령수 M(1 ≤ M ≤ 100000)
    은하수를 건널 수 있는 기차의 수를 구하라.
- 상상 코딩
    아무도 안타고있는 N개의 기차를 원소로 갖는 리스트 생성.
    각 기차는 2진수 2^20. 1의 자리가 20번째.  
    각 명령을 수행하여 각 기차에 저장
        1. i번째 기차, x번째 좌석에 사람태우기 -> 1로 or 연산
        2. i번째 기차, x번째 좌석 하차 -> 0으로 and 연산
        3. i번째 기차 한칸씩 뒤로 -> shift 연산을 오른쪽으로
        4. i번째 기차 한칸씩 앞으로 -> shift 연산 왼쪽으로
    기차를 set하여 길이를 출력

- 체감 난이도 (1:쉬움 ~ 5:매우 어려움)
    4(비트마스킹 생소함)
- 문제 분석

    - 알고리즘 유형 분석
        커맨드 별로, 각 기차에 대해 비트연산을 수행합니다. 비트연산 그리고 브루트포스를 이용한 구현으로 볼 수 있습니다.

    - 시간복잡도 분석
        커맨드가 M개 기차개수가 N개입니다. 커맨드를 반복하며, 커맨드별로 각 기차에 대해 비트연산을 수행합니다.
        각 기차별로 연산은 상수시간 이므로, 전체 시간복잡도는 O(M) 입니다.

    - 리팩토링 방향성
        비트연산을 좀 더 파이써닉하게 바꿔서 보기좋게 바꿀 방향성이 있는 것 같습니다.
    
"""
## 파일로 예제 입력 읽기
import sys
sys.stdin = open("input.txt",'r')
##
import sys
input = sys.stdin.readline
N,M = map(int,input().split())
trains=[0 for _ in range(N+1)] # 1 based index
cmds = [[*map(int,input().split())] for _ in range(M)]
for cmd in cmds:
    if cmd[0]==1:
        tnum, seat = cmd[1:]
        trains[tnum] = trains[tnum] | 1<<seat
    elif cmd[0]==2:
        tnum, seat = cmd[1:]
        trains[tnum] = trains[tnum] & ~(1<<seat)
    elif cmd[0]==3:
        tnum=cmd[1]
        trains[tnum] = (trains[tnum] << 1) & ~(1<<21)
    elif cmd[0]==4:
        tnum=cmd[1]
        trains[tnum] = (trains[tnum] >> 1) & ~(1<<0)
print(len(set(trains[1:])))






